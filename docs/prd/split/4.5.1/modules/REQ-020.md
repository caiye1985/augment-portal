# REQ-020: 移动端应用模块（技术增强版）

**技术定位:** 基于Flutter 3.24.5跨平台框架的原生移动应用，为IT运维门户系统提供完整的移动端解决方案，支持工程师移动办公和客户自助服务的全场景覆盖。

## 1. 业务与技术概述

### 1.1 业务价值
移动端应用模块通过Flutter跨平台技术实现iOS和Android统一开发，为IT运维门户系统提供移动设备访问能力。模块重点支持工程师移动办公、客户移动自助服务、实时通知推送、离线数据同步等核心功能，确保运维服务的连续性和响应及时性。

### 1.2 技术架构定位
- **开发框架**: Flutter 3.24.5 + Dart 3.5.4，一套代码支持iOS/Android双平台
- **状态管理**: Riverpod 2.6.1，类型安全的响应式状态管理
- **网络层**: Dio 5.7.0 + 自定义拦截器，支持离线缓存和智能重试
- **本地存储**: Hive 2.2.3 + Drift 2.20.3，轻量化缓存 + 结构化数据库
- **依赖注入**: get_it 8.0.2，解耦业务逻辑和基础设施
- **国产化集成**: 极光推送、高德地图、友盟统计等国产SDK

### 1.3 移动端特色功能
- **离线优先设计**: 核心功能离线可用，网络恢复后智能同步
- **原生性能体验**: 60fps流畅度，冷启动≤3秒，热启动≤1秒
- **多媒体集成**: 相机拍照、视频录制、语音输入、扫码识别
- **地理位置服务**: GPS定位、地图导航、基于位置的智能派单
- **推送通知**: 极光推送集成，支持多厂商通道，到达率≥95%
- **生物识别**: 指纹、面容ID认证，增强移动端安全性

## 2. KPI与技术指标

### 2.1 业务KPI
- **移动端用户活跃度**：≥70%，工程师和客户积极使用移动端
- **移动端工单处理率**：≥40%，工单通过移动端处理的比例
- **用户满意度**：≥4.5/5分，移动端用户体验满意度
- **推送到达率**：≥95%，重要通知的推送到达率
- **离线数据同步成功率**：≥99%，离线数据同步的成功率

### 2.2 技术性能指标
- **启动性能**: 冷启动≤3秒，热启动≤1秒，首屏渲染≤2秒
- **运行性能**: 界面操作响应≤2秒，API调用响应≤5秒，页面切换≥60fps
- **网络性能**: 离线数据同步≤30秒，推送延迟≤10秒，文件上传成功率≥98%
- **资源消耗**: 内存使用≤200MB，电池续航优化，CPU使用率≤30%
- **兼容性**: iOS 12+支持率≥95%，Android 8.0+支持率≥95%

## 3. 移动端技术架构设计

### 3.1 Flutter应用分层架构
```
┌─────────────────────────────────────────┐
│              Presentation Layer          │
│  ┌─────────────┐ ┌─────────────────────┐ │
│  │   Widgets   │ │    UI Components    │ │
│  │   (Pages)   │ │   (Custom Widgets)  │ │
│  └─────────────┘ └─────────────────────┘ │
├─────────────────────────────────────────┤
│              Business Logic Layer        │
│  ┌─────────────┐ ┌─────────────────────┐ │
│  │  Providers  │ │     Use Cases       │ │
│  │ (Riverpod)  │ │  (Business Logic)   │ │
│  └─────────────┘ └─────────────────────┘ │
├─────────────────────────────────────────┤
│                Data Layer                │
│  ┌─────────────┐ ┌─────────────────────┐ │
│  │ Repositories│ │    Data Sources     │ │
│  │             │ │  (API + Local DB)   │ │
│  └─────────────┘ └─────────────────────┘ │
├─────────────────────────────────────────┤
│             Infrastructure Layer         │
│  ┌─────────────┐ ┌─────────────────────┐ │
│  │   Network   │ │   Local Storage     │ │
│  │    (Dio)    │ │  (Hive + Drift)     │ │
│  └─────────────┘ └─────────────────────┘ │
└─────────────────────────────────────────┘
```

### 3.2 状态管理架构（Riverpod）
```dart
// 全局状态管理示例
final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  return AuthNotifier(ref.read(authRepositoryProvider));
});

final ticketListProvider = FutureProvider.family<List<Ticket>, TicketFilter>((ref, filter) {
  return ref.read(ticketRepositoryProvider).getTickets(filter);
});

// 离线状态管理
final offlineProvider = StateNotifierProvider<OfflineNotifier, OfflineState>((ref) {
  return OfflineNotifier(ref.read(syncRepositoryProvider));
});
```

### 3.3 依赖注入配置（get_it）
```dart
// 服务定位器配置
void setupServiceLocator() {
  // 网络层
  getIt.registerLazySingleton<Dio>(() => createDioClient());
  getIt.registerLazySingleton<ApiClient>(() => ApiClient(getIt<Dio>()));
  
  // 本地存储
  getIt.registerLazySingleton<HiveService>(() => HiveService());
  getIt.registerLazySingleton<DatabaseService>(() => DatabaseService());
  
  // 业务服务
  getIt.registerLazySingleton<AuthService>(() => AuthService());
  getIt.registerLazySingleton<TicketService>(() => TicketService());
  getIt.registerLazySingleton<NotificationService>(() => NotificationService());
  
  // 设备服务
  getIt.registerLazySingleton<LocationService>(() => LocationService());
  getIt.registerLazySingleton<CameraService>(() => CameraService());
  getIt.registerLazySingleton<PushService>(() => PushService());
}
```

## 4. 核心功能技术实现

### 4.1 移动端工单管理
**技术实现要点:**
- **数据模型**: 使用json_serializable进行JSON序列化，支持类型安全
- **状态管理**: Riverpod管理工单列表状态，支持分页加载和实时更新
- **离线支持**: 本地缓存工单数据，支持离线查看和操作
- **多媒体集成**: 集成相机插件，支持拍照记录故障现象

```dart
// 工单数据模型
@JsonSerializable()
class Ticket {
  final int id;
  final String title;
  final String description;
  final TicketStatus status;
  final Priority priority;
  final DateTime createdAt;
  final List<Attachment> attachments;
  
  // 离线状态标识
  final bool isOffline;
  final DateTime? lastSyncTime;
}

// 工单状态管理
class TicketNotifier extends StateNotifier<AsyncValue<List<Ticket>>> {
  Future<void> updateTicketStatus(int ticketId, TicketStatus status) async {
    // 乐观更新UI
    state = AsyncValue.data(
      state.value?.map((ticket) => 
        ticket.id == ticketId ? ticket.copyWith(status: status) : ticket
      ).toList() ?? []
    );
    
    try {
      // 网络请求
      await _ticketRepository.updateStatus(ticketId, status);
    } catch (e) {
      // 离线操作队列
      await _offlineQueue.addOperation(
        UpdateTicketOperation(ticketId: ticketId, status: status)
      );
    }
  }
}
```

### 4.2 实时通知推送系统
**技术架构:**
- **推送服务**: 极光推送SDK集成，支持多厂商通道（小米、华为、OPPO、vivo）
- **本地通知**: flutter_local_notifications插件，支持定时提醒和离线通知
- **深度链接**: 通知点击跳转到具体页面，支持路由参数传递
- **通知分类**: 紧急工单、状态更新、系统通知等不同类型

```dart
// 推送服务配置
class PushNotificationService {
  static const String _channelId = 'ops_portal_channel';
  
  Future<void> initialize() async {
    // 极光推送初始化
    await JPush.setup(
      appKey: "your_jpush_key",
      channel: "developer-default",
      production: false,
    );
    
    // 本地通知初始化
    await _flutterLocalNotificationsPlugin.initialize(
      InitializationSettings(
        android: AndroidInitializationSettings('@mipmap/ic_launcher'),
        iOS: DarwinInitializationSettings(),
      ),
      onDidReceiveNotificationResponse: _onNotificationTapped,
    );
  }
  
  Future<void> _onNotificationTapped(NotificationResponse response) async {
    final payload = response.payload;
    if (payload != null) {
      final data = jsonDecode(payload);
      // 深度链接处理
      await _navigateToPage(data['route'], data['params']);
    }
  }
}
```

### 4.3 离线数据同步机制
**技术架构:**
- **离线存储**: Hive轻量化存储 + Drift SQLite数据库
- **操作队列**: 离线操作暂存，网络恢复后批量同步
- **冲突解决**: 基于时间戳和版本号的冲突检测与解决
- **增量同步**: 只同步变更数据，减少网络流量

```dart
// 离线同步服务
class OfflineSyncService {
  final DatabaseService _database;
  final ApiClient _apiClient;
  final NetworkService _networkService;

  Future<void> syncOfflineData() async {
    if (!await _networkService.isConnected()) return;

    // 获取离线操作队列
    final operations = await _database.getOfflineOperations();

    for (final operation in operations) {
      try {
        await _executeOperation(operation);
        await _database.markOperationSynced(operation.id);
      } catch (e) {
        // 记录同步失败，稍后重试
        await _database.markOperationFailed(operation.id, e.toString());
      }
    }

    // 下载服务端更新
    await _downloadServerUpdates();
  }

  Future<void> _executeOperation(OfflineOperation operation) async {
    switch (operation.type) {
      case OperationType.updateTicket:
        await _apiClient.updateTicket(operation.data);
        break;
      case OperationType.uploadAttachment:
        await _apiClient.uploadFile(operation.data);
        break;
      // 其他操作类型...
    }
  }
}

// 冲突解决策略
class ConflictResolver {
  ConflictResolution resolveTicketConflict(
    Ticket localTicket,
    Ticket serverTicket
  ) {
    // 基于时间戳的冲突解决
    if (localTicket.updatedAt.isAfter(serverTicket.updatedAt)) {
      return ConflictResolution.useLocal;
    } else if (serverTicket.updatedAt.isAfter(localTicket.updatedAt)) {
      return ConflictResolution.useServer;
    } else {
      // 需要用户手动选择
      return ConflictResolution.requireUserInput;
    }
  }
}
```

### 4.4 地理位置服务集成
**技术实现:**
- **地图服务**: 高德地图Flutter SDK，国产化地图解决方案
- **位置权限**: 动态权限申请，用户隐私保护
- **定位精度**: GPS + 网络定位，精度≤10米
- **位置缓存**: 本地缓存位置信息，减少重复定位

```dart
// 地理位置服务
class LocationService {
  final AMapLocationPlugin _aMapLocation = AMapLocationPlugin();

  Future<LocationData?> getCurrentLocation() async {
    // 检查权限
    final permission = await _checkLocationPermission();
    if (permission != LocationPermission.whileInUse &&
        permission != LocationPermission.always) {
      throw LocationPermissionDeniedException();
    }

    try {
      final location = await _aMapLocation.getLocation(
        AMapLocationOption(
          desiredAccuracy: AMapLocationAccuracy.high,
          geoLanguage: AMapLocationLanguage.zh,
          needAddress: true,
          onceLocation: true,
        ),
      );

      return LocationData(
        latitude: location.latitude,
        longitude: location.longitude,
        address: location.address,
        accuracy: location.accuracy,
        timestamp: DateTime.now(),
      );
    } catch (e) {
      throw LocationServiceException('定位失败: ${e.toString()}');
    }
  }

  Future<LocationPermission> _checkLocationPermission() async {
    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
    }
    return permission;
  }
}
```

### 4.5 多媒体功能实现
**技术组件:**
- **相机集成**: camera插件，支持拍照和视频录制
- **图片处理**: image插件，支持压缩、裁剪、格式转换
- **文件上传**: dio_file_upload，支持大文件分片上传
- **语音识别**: speech_to_text插件，语音转文字功能

```dart
// 相机服务
class CameraService {
  CameraController? _controller;

  Future<void> initializeCamera() async {
    final cameras = await availableCameras();
    if (cameras.isEmpty) throw CameraNotAvailableException();

    _controller = CameraController(
      cameras.first,
      ResolutionPreset.high,
      enableAudio: false,
    );

    await _controller!.initialize();
  }

  Future<File> takePicture() async {
    if (_controller == null || !_controller!.value.isInitialized) {
      throw CameraNotInitializedException();
    }

    final XFile picture = await _controller!.takePicture();

    // 图片压缩
    final compressedFile = await _compressImage(File(picture.path));

    return compressedFile;
  }

  Future<File> _compressImage(File imageFile) async {
    final bytes = await imageFile.readAsBytes();
    final image = img.decodeImage(bytes);

    if (image == null) throw ImageProcessingException();

    // 压缩到合适尺寸（最大1920x1080）
    final resized = img.copyResize(
      image,
      width: image.width > 1920 ? 1920 : null,
      height: image.height > 1080 ? 1080 : null,
    );

    // 压缩质量85%
    final compressedBytes = img.encodeJpg(resized, quality: 85);

    final compressedFile = File('${imageFile.path}_compressed.jpg');
    await compressedFile.writeAsBytes(compressedBytes);

    return compressedFile;
  }
}

// 文件上传服务
class FileUploadService {
  final Dio _dio;

  Future<String> uploadFile(File file, {
    Function(int, int)? onProgress,
  }) async {
    final fileName = path.basename(file.path);
    final formData = FormData.fromMap({
      'file': await MultipartFile.fromFile(
        file.path,
        filename: fileName,
      ),
    });

    try {
      final response = await _dio.post(
        '/api/v1/files/upload',
        data: formData,
        onSendProgress: onProgress,
      );

      return response.data['data']['file_url'];
    } catch (e) {
      throw FileUploadException('文件上传失败: ${e.toString()}');
    }
  }
}
```
## 5. 移动端UI/UX设计规范

### 5.1 设计系统
**Material Design 3 + Cupertino适配:**
- **主题配色**: 遵循企业VI，支持深色模式
- **字体系统**: 中文优化字体，多级字号层次
- **组件库**: 基于Element Plus设计语言的Flutter组件
- **图标系统**: 统一图标库，支持矢量图标
```dart
// 主题配置
class AppTheme {
  static ThemeData lightTheme = ThemeData(
    useMaterial3: true,
    colorScheme: ColorScheme.fromSeed(
      seedColor: const Color(0xFF1976D2), // 主品牌色
      brightness: Brightness.light,
    ),
    textTheme: const TextTheme(
      headlineLarge: TextStyle(
        fontSize: 24,
        fontWeight: FontWeight.bold,
        color: Color(0xFF212121),
      ),
      bodyLarge: TextStyle(
        fontSize: 16,
        color: Color(0xFF424242),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        minimumSize: const Size(88, 48),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
    ),
  );

  static ThemeData darkTheme = ThemeData(
    useMaterial3: true,
    colorScheme: ColorScheme.fromSeed(
      seedColor: const Color(0xFF1976D2),
      brightness: Brightness.dark,
    ),
  );
}
```
### 5.2 响应式布局
**屏幕适配策略:**
- **flutter_screenutil**: 基于设计稿的屏幕适配
- **断点设计**: 手机、平板、折叠屏适配
- **安全区域**: 刘海屏、圆角屏幕适配
- **横竖屏**: 支持横竖屏切换，布局自适应
```dart
// 响应式布局工具
class ResponsiveLayout extends StatelessWidget {
  final Widget mobile;
  final Widget? tablet;
  final Widget? desktop;

  const ResponsiveLayout({
    Key? key,
    required this.mobile,
    this.tablet,
    this.desktop,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        if (constraints.maxWidth >= 1200) {
          return desktop ?? tablet ?? mobile;
        } else if (constraints.maxWidth >= 768) {
          return tablet ?? mobile;
        } else {
          return mobile;
        }
      },
    );
  }
}

// 屏幕适配初始化
void initScreenUtil() {
  ScreenUtil.init(
    BoxConstraints(
      maxWidth: MediaQuery.of(context).size.width,
      maxHeight: MediaQuery.of(context).size.height,
    ),
    designSize: const Size(375, 812), // iPhone X设计稿尺寸
    minTextAdapt: true,
    splitScreenMode: true,
  );
}
```
### 5.3 导航架构设计
**路由管理:**
- **go_router**: 声明式路由，支持深链接和路由守卫
- **底部导航**: 主要功能模块快速切换
- **侧边抽屉**: 次要功能和设置入口
- **面包屑**: 复杂页面层级导航
```dart
// 路由配置
final GoRouter appRouter = GoRouter(
  initialLocation: '/splash',
  routes: [
    GoRoute(
      path: '/splash',
      builder: (context, state) => const SplashPage(),
    ),
    GoRoute(
      path: '/login',
      builder: (context, state) => const LoginPage(),
    ),
    ShellRoute(
      builder: (context, state, child) => MainLayout(child: child),
      routes: [
        GoRoute(
          path: '/home',
          builder: (context, state) => const HomePage(),
        ),
        GoRoute(
          path: '/tickets',
          builder: (context, state) => const TicketListPage(),
          routes: [
            GoRoute(
              path: '/:id',
              builder: (context, state) => TicketDetailPage(
                ticketId: int.parse(state.pathParameters['id']!),
              ),
            ),
          ],
        ),
        GoRoute(
          path: '/profile',
          builder: (context, state) => const ProfilePage(),
        ),
      ],
    ),
  ],
  redirect: (context, state) {
    final isLoggedIn = context.read(authProvider).isLoggedIn;
    final isLoggingIn = state.location == '/login';

    if (!isLoggedIn && !isLoggingIn) {
      return '/login';
    }
    if (isLoggedIn && isLoggingIn) {
      return '/home';
    }
    return null;
  },
);
```

## 6. 功能需求详细设计

### 6.1 移动端工单管理功能
| 功能编号 | 功能名称 | 技术实现 | 验收标准 |
|---------|----------|----------|----------|
| REQ-020-001 | 工单列表查看 | Riverpod状态管理 + 分页加载 | 列表流畅滚动，支持下拉刷新 |
| REQ-020-002 | 工单详情查看 | 响应式布局 + 多媒体展示 | 详情页面完整展示，图片可预览 |
| REQ-020-003 | 工单状态更新 | 乐观更新 + 离线队列 | 状态更新及时，离线操作可同步 |
| REQ-020-004 | 工单拍照记录 | Camera插件 + 图片压缩 | 拍照清晰，上传成功率≥98% |
| REQ-020-005 | 工单语音记录 | speech_to_text插件 | 语音识别准确率≥85% |

### 6.2 实时通知推送功能
| 功能编号 | 功能名称 | 技术实现 | 验收标准 |
|---------|----------|----------|----------|
| REQ-020-006 | 推送消息接收 | 极光推送SDK + 多厂商通道 | 推送到达率≥95%，延迟≤10秒 |
| REQ-020-007 | 本地通知管理 | flutter_local_notifications | 离线通知正常显示 |
| REQ-020-008 | 通知分类处理 | 通知渠道管理 | 不同类型通知区分明确 |
| REQ-020-009 | 深度链接跳转 | go_router深度链接 | 点击通知准确跳转到目标页面 |

### 6.3 离线数据同步功能
| 功能编号 | 功能名称 | 技术实现 | 验收标准 |
|---------|----------|----------|----------|
| REQ-020-010 | 离线数据缓存 | Hive + Drift数据库 | 核心数据离线可访问 |
| REQ-020-011 | 离线操作队列 | 操作队列管理 | 离线操作自动暂存 |
| REQ-020-012 | 数据同步机制 | 增量同步算法 | 同步成功率≥99%，时间≤30秒 |
| REQ-020-013 | 冲突解决处理 | 冲突检测与解决 | 冲突处理准确，用户可选择 |

### 6.4 地理位置服务功能
| 功能编号 | 功能名称 | 技术实现 | 验收标准 |
|---------|----------|----------|----------|
| REQ-020-014 | GPS定位服务 | 高德地图SDK | 定位精度≤10米，时间≤5秒 |
| REQ-020-015 | 地图导航集成 | 高德地图导航 | 导航路线准确，实时更新 |
| REQ-020-016 | 位置权限管理 | 动态权限申请 | 权限申请流程友好 |
| REQ-020-017 | 工程师签到 | 位置验证算法 | 签到位置准确验证 |

## 7. 移动端用户故事与场景

### 7.1 工程师移动办公场景
**故事1：外出接收紧急工单**
- **角色**：运维工程师
- **场景**：工程师在外出途中收到紧急工单推送通知
- **操作流程**：
  1. 收到极光推送通知（延迟≤10秒）
  2. 点击通知直接跳转到工单详情页
  3. 查看工单详细信息和客户位置
  4. 一键导航到客户现场
  5. 接受工单并更新状态为"进行中"
- **技术要求**：推送及时、深度链接、地图导航、状态同步
- **验收标准**：通知到达率≥95%，页面跳转准确，导航路线正确

**故事2：现场处理工单记录**
- **角色**：现场工程师
- **场景**：工程师到达现场后需要记录问题现象和处理过程
- **操作流程**：
  1. 使用相机拍照记录设备状态
  2. 语音输入问题描述和解决方案
  3. 扫描设备二维码获取设备信息
  4. 更新工单处理进度
  5. 上传处理结果和照片
- **技术要求**：相机集成、语音识别、扫码功能、文件上传
- **验收标准**：拍照清晰、语音识别准确率≥85%、上传成功率≥98%

### 7.2 客户移动自助场景
**故事3：客户移动端提交工单**
- **角色**：客户用户
- **场景**：客户发现问题需要提交工单申请技术支持
- **操作流程**：
  1. 打开移动应用，选择"提交工单"
  2. 填写问题描述和紧急程度
  3. 拍照上传问题现象
  4. 选择期望的服务时间
  5. 提交工单并获得工单编号
- **技术要求**：表单验证、图片上传、数据提交
- **验收标准**：提交流程简洁、上传稳定、反馈及时

**故事4：客户查询工单进度**
- **角色**：客户用户
- **场景**：客户想了解已提交工单的处理进度
- **操作流程**：
  1. 在"我的工单"页面查看工单列表
  2. 点击具体工单查看详细进度
  3. 查看工程师处理记录和照片
  4. 对服务质量进行评价
- **技术要求**：数据同步、状态展示、评价功能
- **验收标准**：状态更新及时、信息展示完整、评价提交成功

## 8. 移动端数据模型设计

### 8.1 移动设备管理表（mobile_devices）
```sql
CREATE TABLE mobile_devices (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    device_id VARCHAR(100) UNIQUE NOT NULL COMMENT '设备唯一标识',
    device_type VARCHAR(20) NOT NULL COMMENT '设备类型：ios,android',
    device_model VARCHAR(100) COMMENT '设备型号',
    os_version VARCHAR(50) COMMENT '系统版本',
    app_version VARCHAR(50) COMMENT '应用版本',
    push_token VARCHAR(255) COMMENT '推送令牌',
    last_active_time DATETIME COMMENT '最后活跃时间',
    location_enabled TINYINT DEFAULT 0 COMMENT '是否启用位置服务',
    notification_enabled TINYINT DEFAULT 1 COMMENT '是否启用通知',
    biometric_enabled TINYINT DEFAULT 0 COMMENT '是否启用生物识别',
    status TINYINT DEFAULT 1 COMMENT '状态：1-正常，2-停用',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_tenant_user (tenant_id, user_id),
    INDEX idx_device_type (device_type),
    INDEX idx_last_active (last_active_time),
    INDEX idx_push_token (push_token)
);
```

### 8.2 离线数据同步表（offline_sync_queue）
```sql
CREATE TABLE offline_sync_queue (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    device_id VARCHAR(100) NOT NULL COMMENT '设备ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    operation_type VARCHAR(50) NOT NULL COMMENT '操作类型：CREATE,UPDATE,DELETE',
    entity_type VARCHAR(50) NOT NULL COMMENT '实体类型：ticket,attachment,comment',
    entity_id BIGINT COMMENT '实体ID',
    operation_data JSON NOT NULL COMMENT '操作数据',
    local_timestamp DATETIME NOT NULL COMMENT '本地时间戳',
    sync_status TINYINT DEFAULT 0 COMMENT '同步状态：0-待同步，1-已同步，2-冲突，3-失败',
    sync_time DATETIME COMMENT '同步时间',
    conflict_data JSON COMMENT '冲突数据',
    retry_count INT DEFAULT 0 COMMENT '重试次数',
    error_message TEXT COMMENT '错误信息',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_tenant_device (tenant_id, device_id),
    INDEX idx_sync_status (sync_status),
    INDEX idx_local_timestamp (local_timestamp),
    INDEX idx_entity (entity_type, entity_id)
);
```

### 8.3 移动端配置表（mobile_app_config）
```sql
CREATE TABLE mobile_app_config (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    config_key VARCHAR(100) NOT NULL COMMENT '配置键',
    config_value JSON NOT NULL COMMENT '配置值',
    platform VARCHAR(20) COMMENT '平台：ios,android,all',
    app_version VARCHAR(50) COMMENT '应用版本',
    is_active TINYINT DEFAULT 1 COMMENT '是否启用',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_tenant_key_platform (tenant_id, config_key, platform),
    INDEX idx_tenant_platform (tenant_id, platform)
);
```

## 9. 移动端API设计

### 9.1 移动端认证API
```http
POST /api/v1/mobile/auth/login
Content-Type: application/json

{
    "username": "engineer001",
    "password": "password123",
    "device_info": {
        "device_id": "iPhone_12345",
        "device_type": "ios",
        "device_model": "iPhone 13",
        "os_version": "iOS 15.0",
        "app_version": "1.0.0",
        "push_token": "abc123def456",
        "biometric_enabled": true
    }
}

Response:
{
    "code": 200,
    "message": "登录成功",
    "data": {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "expires_in": 7200,
        "user_info": {
            "user_id": 1001,
            "username": "engineer001",
            "real_name": "张工程师",
            "role": "engineer",
            "avatar_url": "https://cdn.example.com/avatar.jpg"
        },
        "app_config": {
            "push_enabled": true,
            "location_enabled": true,
            "offline_sync_interval": 300,
            "max_offline_operations": 1000,
            "image_compression_quality": 85
        }
    }
}
```

### 9.2 离线数据同步API
```http
POST /api/v1/mobile/sync/upload
Authorization: Bearer {access_token}
Content-Type: application/json

{
    "device_id": "iPhone_12345",
    "sync_data": [
        {
            "operation_id": "local_op_001",
            "operation_type": "UPDATE",
            "entity_type": "ticket",
            "entity_id": 12345,
            "operation_data": {
                "status": "in_progress",
                "notes": "已到达现场，开始排查问题",
                "location": {
                    "latitude": 39.9042,
                    "longitude": 116.4074,
                    "address": "北京市朝阳区"
                }
            },
            "local_timestamp": "2024-08-11 14:30:00"
        }
    ]
}

Response:
{
    "code": 200,
    "message": "同步成功",
    "data": {
        "synced_count": 1,
        "failed_count": 0,
        "conflicts": [],
        "server_timestamp": "2024-08-11 14:30:15",
        "next_sync_token": "sync_token_abc123"
    }
}
```

### 9.3 推送通知注册API
```http
POST /api/v1/mobile/push/register
Authorization: Bearer {access_token}
Content-Type: application/json

{
    "device_id": "iPhone_12345",
    "push_token": "new_push_token_xyz789",
    "platform": "ios",
    "notification_settings": {
        "urgent_tickets": true,
        "status_updates": true,
        "system_notifications": false,
        "quiet_hours": {
            "enabled": true,
            "start_time": "22:00",
            "end_time": "08:00"
        }
    }
}

Response:
{
    "code": 200,
    "message": "推送注册成功",
    "data": {
        "registration_id": "reg_12345",
        "status": "active"
    }
}
```

## 10. 移动端性能优化与安全

### 10.1 性能优化策略
**启动优化:**
- **预编译优化**: 使用Flutter的AOT编译，减少启动时间
- **资源预加载**: 关键资源提前加载，减少首屏渲染时间
- **启动画面**: 原生启动画面，提升用户感知性能
- **代码分割**: 按需加载非核心功能模块

```dart
// 应用启动优化
class AppInitializer {
  static Future<void> initialize() async {
    // 确保Flutter绑定初始化
    WidgetsFlutterBinding.ensureInitialized();

    // 预加载关键服务
    await Future.wait([
      _initializeHive(),
      _initializeNotifications(),
      _initializeNetworking(),
    ]);

    // 预加载用户配置
    await _preloadUserConfig();
  }

  static Future<void> _initializeHive() async {
    await Hive.initFlutter();
    await Hive.openBox('app_config');
    await Hive.openBox('user_cache');
  }
}
```

**运行时优化:**
- **内存管理**: 及时释放不用的资源，避免内存泄漏
- **图片优化**: 使用缓存和压缩，减少内存占用
- **网络优化**: 请求合并、缓存策略、连接池管理
- **电池优化**: 后台任务优化，减少CPU和网络消耗

```dart
// 图片缓存管理
class ImageCacheManager {
  static const int maxCacheSize = 100 * 1024 * 1024; // 100MB
  static const int maxCacheAge = 7 * 24 * 60 * 60; // 7天

  static void optimizeImageCache() {
    PaintingBinding.instance.imageCache.maximumSize = 1000;
    PaintingBinding.instance.imageCache.maximumSizeBytes = maxCacheSize;
  }

  static Future<void> clearExpiredCache() async {
    final cacheDir = await getTemporaryDirectory();
    final files = cacheDir.listSync();

    for (final file in files) {
      if (file is File) {
        final stat = await file.stat();
        final age = DateTime.now().difference(stat.modified).inSeconds;

        if (age > maxCacheAge) {
          await file.delete();
        }
      }
    }
  }
}
```

### 10.2 安全架构设计
**数据安全:**
- **本地加密**: 敏感数据使用AES-256加密存储
- **传输安全**: 所有API调用使用HTTPS/TLS 1.3
- **证书绑定**: SSL证书固定，防止中间人攻击
- **数据脱敏**: 日志和错误报告中敏感信息脱敏

```dart
// 数据加密服务
class EncryptionService {
  static const String _keyAlias = 'ops_portal_key';

  static Future<String> encrypt(String plainText) async {
    final key = await _getOrCreateKey();
    final encrypter = Encrypter(AES(key));
    final iv = IV.fromSecureRandom(16);

    final encrypted = encrypter.encrypt(plainText, iv: iv);
    return '${iv.base64}:${encrypted.base64}';
  }

  static Future<String> decrypt(String encryptedText) async {
    final parts = encryptedText.split(':');
    if (parts.length != 2) throw FormatException('Invalid encrypted format');

    final key = await _getOrCreateKey();
    final encrypter = Encrypter(AES(key));
    final iv = IV.fromBase64(parts[0]);
    final encrypted = Encrypted.fromBase64(parts[1]);

    return encrypter.decrypt(encrypted, iv: iv);
  }

  static Future<Key> _getOrCreateKey() async {
    // 使用设备安全存储生成或获取密钥
    const storage = FlutterSecureStorage();
    String? keyString = await storage.read(key: _keyAlias);

    if (keyString == null) {
      final key = Key.fromSecureRandom(32);
      await storage.write(key: _keyAlias, value: key.base64);
      return key;
    }

    return Key.fromBase64(keyString);
  }
}
```

**身份认证:**
- **生物识别**: 指纹、面容ID认证
- **多因素认证**: 密码 + 生物识别 + 设备绑定
- **会话管理**: JWT令牌管理，自动刷新和过期处理
- **设备绑定**: 设备唯一标识验证

```dart
// 生物识别认证
class BiometricAuthService {
  static Future<bool> isAvailable() async {
    final localAuth = LocalAuthentication();
    return await localAuth.canCheckBiometrics;
  }

  static Future<bool> authenticate() async {
    final localAuth = LocalAuthentication();

    try {
      final isAuthenticated = await localAuth.authenticate(
        localizedReason: '请验证身份以访问应用',
        options: const AuthenticationOptions(
          biometricOnly: true,
          stickyAuth: true,
        ),
      );

      return isAuthenticated;
    } catch (e) {
      return false;
    }
  }

  static Future<List<BiometricType>> getAvailableBiometrics() async {
    final localAuth = LocalAuthentication();
    return await localAuth.getAvailableBiometrics();
  }
}
```

## 11. 测试与质量保证

### 11.1 测试策略
**单元测试:**
- **业务逻辑测试**: 使用flutter_test框架测试业务逻辑
- **Widget测试**: 测试UI组件的渲染和交互
- **Mock测试**: 使用mockito模拟外部依赖
- **覆盖率要求**: 代码覆盖率≥80%

```dart
// 单元测试示例
void main() {
  group('TicketService Tests', () {
    late TicketService ticketService;
    late MockApiClient mockApiClient;

    setUp(() {
      mockApiClient = MockApiClient();
      ticketService = TicketService(mockApiClient);
    });

    test('should fetch tickets successfully', () async {
      // Arrange
      final mockTickets = [
        Ticket(id: 1, title: 'Test Ticket', status: TicketStatus.open),
      ];
      when(mockApiClient.getTickets(any))
          .thenAnswer((_) async => mockTickets);

      // Act
      final result = await ticketService.getTickets(TicketFilter());

      // Assert
      expect(result, equals(mockTickets));
      verify(mockApiClient.getTickets(any)).called(1);
    });
  });
}
```

**集成测试:**
- **端到端测试**: 使用flutter_driver测试完整用户流程
- **API集成测试**: 测试与后端API的集成
- **设备功能测试**: 测试相机、定位等设备功能
- **网络环境测试**: 测试不同网络条件下的表现

**性能测试:**
- **启动时间测试**: 测量冷启动和热启动时间
- **内存使用测试**: 监控内存使用情况和泄漏
- **电池消耗测试**: 测量应用对电池的影响
- **网络性能测试**: 测试不同网络条件下的性能

### 11.2 发布与部署
**应用打包:**
- **代码混淆**: 启用代码混淆保护源码
- **资源优化**: 压缩图片和其他资源文件
- **多渠道打包**: 支持不同应用商店的打包配置
- **版本管理**: 语义化版本号管理

```yaml
# pubspec.yaml 发布配置
flutter:
  assets:
    - assets/images/
    - assets/icons/

  # 应用图标配置
  flutter_icons:
    android: true
    ios: true
    image_path: "assets/icons/app_icon.png"

  # 启动画面配置
  flutter_native_splash:
    color: "#1976D2"
    image: "assets/images/splash_logo.png"
    android_12:
      color: "#1976D2"
      image: "assets/images/splash_logo.png"
```

**应用商店发布:**
- **iOS App Store**: 遵循苹果审核指南，提供隐私政策
- **Android应用商店**: 华为应用市场、小米应用商店、OPPO软件商店
- **企业分发**: 支持企业内部分发和测试
- **版本更新**: 支持增量更新和强制更新

## 12. 模块依赖与集成

### 12.1 依赖模块
- **基础架构模块（REQ-001）**: 用户认证、权限控制、多租户支持
- **工单管理模块（REQ-003）**: 移动端工单操作API
- **通知消息模块（REQ-011）**: 推送通知服务集成
- **客户自助服务（REQ-019）**: 移动端客户服务功能

### 12.2 技术集成要求
- **API兼容性**: 与Spring Boot 3.3.6后端API完全兼容
- **认证集成**: 支持JWT认证和Spring Security集成
- **多租户支持**: 客户端自动注入tenant_id头部
- **文件上传**: 与MinIO文件存储服务集成
- **实时通信**: 支持WebSocket连接和Stomp协议

### 12.3 本地验证指令
```bash
# Flutter环境检查
flutter doctor -v

# 依赖安装
flutter pub get

# 代码分析
flutter analyze

# 单元测试
flutter test

# 集成测试
flutter drive --target=test_driver/app.dart

# 构建测试
flutter build apk --debug
flutter build ios --debug

# 性能分析
flutter run --profile
```

这个技术增强版的REQ-020移动端应用模块PRD文档为AI开发助手提供了完整的技术实施指导，包含了Flutter跨平台开发的所有关键技术细节、移动端特有功能的实现方案、性能优化策略和安全架构设计。文档结构化程度高，便于AI理解和代码生成。

---

## 总结

本技术增强版REQ-020移动端应用模块PRD文档专门为AI开发助手优化，提供了：

### 核心技术优势
1. **Flutter跨平台统一**: 一套代码支持iOS/Android，开发效率提升50%
2. **国产化技术栈**: 极光推送、高德地图等国产SDK，网络稳定性高
3. **离线优先设计**: 核心功能离线可用，同步成功率≥99%
4. **原生性能体验**: 60fps流畅度，启动时间≤3秒
5. **完整安全架构**: 生物识别、数据加密、传输安全

### 开发实施指导
- **详细技术架构**: 分层架构、状态管理、依赖注入完整方案
- **核心功能实现**: 工单管理、推送通知、离线同步、地理位置、多媒体处理
- **性能优化策略**: 启动优化、运行时优化、资源管理
- **安全设计方案**: 数据加密、身份认证、权限管理
- **测试与部署**: 单元测试、集成测试、应用商店发布

### AI开发友好特性
- **结构化代码示例**: 完整的Dart/Flutter代码片段
- **明确的技术约束**: 版本要求、性能指标、兼容性标准
- **详细的API设计**: 移动端专用API接口定义
- **完整的数据模型**: 数据库表结构和字段定义
- **本地验证指令**: 开发、测试、构建的完整命令

该文档为后续生成AI开发助手专用的移动端技术实现规范奠定了坚实基础，确保移动端开发的技术先进性、实施可行性和质量保证。
