**核心原则（不忘初心）**  
- 所有文档的生成都必须围绕一个目标：**让 AI 最终能基于 API 文档 + 需求 PRD 并行正确生成后端 / 前端 / 移动端代码**  
- 生成顺序必须保证**依赖关系**的逻辑性和准确性，否则 AI 会出现错配、字段不一致的问题
- 三端 PRD（Backend / Frontend / Mobile）**依赖 API 文档**，因为它们里面的接口调用、数据结构、权限等都要与 API 对齐  

---

## 📌 依赖链设计

我会把生成链路定为：

```
1. 原始需求 PRD（appendix + globals + modules）
   ↓
2. 初版 API 文档骨架（api-docs.md + openapi.yaml）
   ↓
3. 分批精修 API 文档（continue_api_completion.sh）
   ↓
4. 在定稿 API 文档基础上，生成三端 PRD 骨架：
      4.1 backend-prd.md
      4.2 frontend-prd.md
      4.3 mobile-prd.md
   ↓
5. 分批精修 Backend / Frontend / Mobile（各自 continue_xxx_completion.sh）
```

**这样保证三端 PRD 引用的 API 信息来源于已经确认过的 API 文档，不会出现“API 改动但三端没更新”的问题**。

---

## 🔹 核心规则

### 1. 先 API
- API 骨架生成时，从 `modules/` 源数据提炼接口占位信息
- 分批精修 API 直至每个 REQ-ID 模块的接口描述完整、准确、全覆盖
- 保证 `api-docs.md` 与 `openapi.yaml` 一致且可用

### 2. 再三端
- 三端 PRD 生成 Prompt 时，必须：
  - 引用 API 文档中该模块的所有接口定义（直接贴 API 文档片段）
  - 标明该端对这些接口的使用方式 / 业务逻辑
  - 保证字段名、参数一致
- 这样三端 PRD 和 API 之间是有显式参照的，不会走偏

### 3. Prompt 设计要“不忘初心”
- Prompt 必须告诉 AI：
  1. “你的输出必须与 API 文档严格一致”
  2. “REQ-ID 必须完全覆盖”
  3. “不要随意添加 API 文档里不存在的接口”
  4. “如果 API 文档缺内容，应明确指出需要修改 API 文档，再更新本 PRD”
  5. “每个功能描述里都引用 API 路径（例如 POST /api/users/login）”

---

1、`scripts/generate_api_from_prd.sh`（生成 API 骨架）
2、跑 `continue_api_completion.sh` 精修各模块

3、

## 📌 下一步执行建议

1. 我先帮你做：
   - `scripts/generate_api_from_prd.sh`（生成 API 骨架）
   - 跑 `continue_api_completion.sh` 精修各模块
2. 当 API 全部完成后
   - `scripts/generate_3x_prd_from_api.sh`（引用精修 API 生成三端骨架）
   - 用 `continue_backend_completion.sh` /  `continue_frontend_completion.sh` /  `continue_mobile_completion.sh` 依次补全
3. 最终获得完整闭环：
   - API 文档 + 三端 PRD 对齐
   - 所有 REQ-ID 覆盖
   - AI 可以直接根据这两类文档生成对应端代码  

---

我可以现在就给你写 **`generate_api_from_prd.sh`（第一阶段）**，生成 API 骨架，并内含“为后续三端生成留钩子”，你看我们先做这一步对吗？这样你今天就能跑出来 API 文档骨架，明天就能开始 API 精修，之后三端再进场。👌 我明白了，你的意思是：  
---

**核心原则（不忘初心）**  
- 所有文档的生成都必须围绕一个目标：**让 AI 最终能基于 API 文档 + 需求 PRD 并行正确生成后端 / 前端 / 移动端代码**  
- 生成顺序必须保证**依赖关系**的逻辑性和准确性，否则 AI 会出现错配、字段不一致的问题
- 三端 PRD（Backend / Frontend / Mobile）**依赖 API 文档**，因为它们里面的接口调用、数据结构、权限等都要与 API 对齐  

---

## 📌 依赖链设计

我会把生成链路定为：

```
1. 原始需求 PRD（appendix + globals + modules）
   ↓
2. 初版 API 文档骨架（api-docs.md + openapi.yaml）
   ↓
3. 分批精修 API 文档（continue_api_completion.sh）
   ↓
4. 在定稿 API 文档基础上，生成三端 PRD 骨架：
      4.1 backend-prd.md
      4.2 frontend-prd.md
      4.3 mobile-prd.md
   ↓
5. 分批精修 Backend / Frontend / Mobile（各自 continue_xxx_completion.sh）
```

**这样保证三端 PRD 引用的 API 信息来源于已经确认过的 API 文档，不会出现“API 改动但三端没更新”的问题**。

---

## 🔹 核心规则

### 1. 先 API
- API 骨架生成时，从 `modules/` 源数据提炼接口占位信息
- 分批精修 API 直至每个 REQ-ID 模块的接口描述完整、准确、全覆盖
- 保证 `api-docs.md` 与 `openapi.yaml` 一致且可用

### 2. 再三端
- 三端 PRD 生成 Prompt 时，必须：
  - 引用 API 文档中该模块的所有接口定义（直接贴 API 文档片段）
  - 标明该端对这些接口的使用方式 / 业务逻辑
  - 保证字段名、参数一致
- 这样三端 PRD 和 API 之间是有显式参照的，不会走偏

### 3. Prompt 设计要“不忘初心”
- Prompt 必须告诉 AI：
  1. “你的输出必须与 API 文档严格一致”
  2. “REQ-ID 必须完全覆盖”
  3. “不要随意添加 API 文档里不存在的接口”
  4. “如果 API 文档缺内容，应明确指出需要修改 API 文档，再更新本 PRD”
  5. “每个功能描述里都引用 API 路径（例如 POST /api/users/login）”

---

## 🖥 改进后的生成器思路

我会给你写两个阶段的脚本：

### 阶段 1 —— 生成 API 文档骨架  
```
scripts/generate_api_from_prd.sh
```
- 输入：`appendix/` + `globals/` + `modules/`
- 输出：  
  - `docs/output/<ver>/api-docs.md`（含各模块接口占位）  
  - `docs/output/<ver>/openapi.yaml`（paths 部分是占位）  

### 阶段 2 —— API 定稿后再生成三端 PRD 骨架  
```
scripts/generate_3x_prd_from_api.sh
```
- 输入：  
  - `api-docs.md`（已精修过的）  
  - 每个模块原始 PRD（modules/）
- 输出：  
  - backend-prd.md  
  - frontend-prd.md  
  - mobile-prd.md  
- 每个三端 PRD 模块引导 prompt 自动引用 API 片段

---

## 🔹 三端 Prompt 样例（不忘初心版）

```markdown
你是高级系统架构师与技术文档专家。

## 背景
- 系统版本: 4.5
- 当前已有 API 文档: docs/output/4.5/api-docs.md （完整且已验证）
- PRD 类型: Backend PRD
- 目标模块: 用户管理模块 (REQ-001)

## 任务要求
1. 基于目标模块的 API 定义（如下引用），补全 Backend PRD 详细需求：
   - 功能概述
   - 数据流 + 业务逻辑
   - 数据输入 / 输出
   - 权限 & 安全控制
   - 异常处理
2. 确保与 API 文档字段、路径、参数完全一致
3. 覆盖本模块所有 REQ-ID 对应的功能需求
4. 如果发现 API 文档存在缺失，请注明（但不要擅自改 API）

## 引用的 API 接口
```
<从 api-docs.md 中提取该模块的接口定义>
```

## 模块原始需求 PRD
```
<modules/REQ-001.md 原文>
```

## 输出要求
- 生成完整的 Backend PRD（更新 docs/output/4.5/backend-prd.md 的该模块内容）
- 其它模块保持原样
```

---

## 📌 下一步执行建议

1. 我先帮你做：
   - `scripts/generate_api_from_prd.sh`（生成 API 骨架）
   - 跑 `continue_api_completion.sh` 精修各模块
2. 当 API 全部完成后
   - `scripts/generate_3x_prd_from_api.sh`（引用精修 API 生成三端骨架）
   - 用 `continue_backend_completion.sh` /  `continue_frontend_completion.sh` /  `continue_mobile_completion.sh` 依次补全
3. 最终获得完整闭环：
   - API 文档 + 三端 PRD 对齐
   - 所有 REQ-ID 覆盖
   - AI 可以直接根据这两类文档生成对应端代码  

---

我可以现在就给你写 **`generate_api_from_prd.sh`（第一阶段）**，生成 API 骨架，并内含“为后续三端生成留钩子”，你看我们先做这一步对吗？这样你今天就能跑出来 API 文档骨架，明天就能开始 API 精修，之后三端再进场。